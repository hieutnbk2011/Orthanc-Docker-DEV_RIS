<?php
namespace App\Models;
use \DB;
use \Debugbar;
use ReallySimpleJWT\Token;

class Orthanc  {

    private $OrthancURL;
    private $lastQueryID;
    private $lastQueryPath;
    public $result;
    public $server;
//     public $showAll;
    public $curlerror;
    private static $debug = true;
    private static $dcmtk_path = '/usr/local/opt/dcmtk/bin/';
    private static $Authorization = 'Bearer CURLTOKEN';
    private static $Token = 'wxwzisme';
    private $origin;
    private static $fulltags = true;

    public function __construct() {

    	$this->curlerror = false;
    	if (!isset($_SESSION["orthanc_host"])) {

    		if (config('myconfigs.DEFAULT_ORTHANC_HOST') == "") die("No Default Orthanc Configured.");
    		$_SESSION["orthanc_host"] = config('myconfigs.DEFAULT_ORTHANC_HOST');
    	}

    	$this->initServer($_SESSION["orthanc_host"]);
    	$this->origin = self::my_server_url();
//     	$this->showAll = false;

    }

    // Setup the Server local and remote REST API URLS, sets the flag for what kind of server it is also, local or remote.

	public function initServer($serverid) {

		if (!empty($serverid)) {

	    $query = 'SELECT * from orthanc_hosts WHERE id = ?';
	    $results = DB::select($query, [$serverid]);
    	$this->server = (object)$results[0];
    	$this->OrthancURL = $this->server->api_url;
		}
		else {
			$this->server = false;
		}
// 		$this->logVariable($this->server);
		Debugbar::error($this->server);
	}

    private static function my_server_url() {

        $server_name = $_SERVER['SERVER_NAME'];

        if (!in_array($_SERVER['SERVER_PORT'], [80, 443])) {
            $port = ":$_SERVER[SERVER_PORT]";
        } else {
            $port = '';
        }

        if (!empty($_SERVER['HTTPS']) && (strtolower($_SERVER['HTTPS']) == 'on' || $_SERVER['HTTPS'] == '1')) {
            $scheme = 'https';
        } else {
            $scheme = 'http';
        }
        return $scheme.'://'.$server_name.$port;
    }


    public function getAPIURL() {

        return $this->OrthancURL;

    }

    public static function logVariable($var) {

		if (gettype($var) == "array" || gettype($var) == "object") {

			ob_start();
			echo json_encode($var, JSON_PRETTY_PRINT);
			$output = ob_get_clean();

		}
		else {
		$output = $var;
		}
		if (self::$debug) Debugbar::error($output);
		return $output;

	}

	// Utility Function

    private static function validateDate($date, $format = 'Y-m-d') {
		$d = DateTime::createFromFormat($format, $date);
		// The Y ( 4 digits year ) returns TRUE for any integer with any number of digits so changing the comparison from == to === fixes the issue.
		return $d && $d->format($format) === $date;
	}

	//  GENERIC THINGS TO VALIDATE AN ORTHANC UUID and DICOM tag codes

	private static function checkUUID($uuid) {

		preg_match('/[0-9a-fa-f]{8}\-[0-9a-fa-f]{8}\-[0-9a-fa-f]{8}\-[0-9a-fa-f]{8}\-[0-9a-fa-f]{8}/', $uuid, $matches);
		return (count($matches) == 1);
	}

	private static function checkTagCode($tagcode) {

		preg_match('/[0-9]{4}\,[0-9]{4}/', $tagcode, $matches);
		return (count($matches) == 1);
	}
/**
THESE ARE ALL FOR MAKING API CALL VIA THE NGINX PROXY WITH AUTHENTICATION, MUCH EAISER THAN THE OTHER WAY
NEED TO PASS AUTH in the Headers as a token and have the Origin of the Server here and on the NGINX server
Used for downloadDCMStudyUUID, downloadZipStudyUUID
**/


	public function executeCURL($CURLOPT_URL) {


		$ch = curl_init();
		curl_setopt($ch, CURLOPT_URL, $this->OrthancURL . '/' . $CURLOPT_URL);
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
		curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
		curl_setopt($ch,CURLOPT_ENCODING , "gzip");
		self::logVariable("executeCURL:  " . $this->OrthancURL . $CURLOPT_URL);
		$headers = array();
		$headers[] = 'Content-Type: application/x-www-form-urlencoded';
		$headers[] = 'Authorization:' . self::$Authorization;
		$headers[] = 'Token:' . self::$Token;
		$headers[] = 'Origin:' . $this->origin;
		$headers[] = 'Accept-Encoding:gzip';

		curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
		$this->result = curl_exec($ch);

		if (curl_errno($ch)) {

			$this->curlerror = true;
			$this->result = curl_errno($ch);
			curl_close($ch);
			return $this->result;
		}
		curl_close($ch);
		$this->curlerror = false;
		return $this->result;

	}

	public function executeCURLPOSTJSON($JSONQuery, $url) {
/**
Used by performQuery for local requests, results can vary, depending upon the Level, Query and Expand.
This takes the whole JSON string and POST the request.
e.g curl --request POST --url http://localhost:8042/tools/find \ --data '{"Level" : "Study","Query" : {"AccessionNumber" : "DEVACC00000008"},"Expand":true}'
* is a wildcard in a search
Dates are Ymd format, - is used for range, after or before.
Generated by curl-to-PHP: http://incarnate.github.io/curl-to-php/

"ID": "5af318ac-78fb-47ff-b0b0-0df18b0588e0",  The ID can be used for subsequent queries
"Path": "/queries/5af318ac-78fb-47ff-b0b0-0df18b0588e0"
**/
		$ch = curl_init();
		curl_setopt($ch, CURLOPT_URL, $this->OrthancURL . $url);
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
		curl_setopt($ch, CURLOPT_POST, 1);
		curl_setopt($ch, CURLOPT_POSTFIELDS, $JSONQuery);
		curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
		curl_setopt($ch,CURLOPT_ENCODING , "gzip");
		self::logVariable("OrthancModel->executeCURLPOSTJSON:  " . $this->OrthancURL . $url);
		self::logVariable("OrthancModel->executeCURLPOSTJSON_Args:  " . $JSONQuery);
		$headers = array();
		$headers[] = 'Authorization:' . self::$Authorization;
		$headers[] = 'Token:' . self::$Token;
		$headers[] = 'Origin:' . $this->origin;
		$headers[] = 'Accept-Encoding:gzip';
		// $headers[] = 'Content-Type: application/json';
		curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
		// DatabaseFactory::logVariable(curl_getinfo($ch));
		$this->result = curl_exec($ch);
		self::logVariable($this->result);
		if (curl_errno($ch)) {

			$this->curlerror = true;
			$this->result = curl_errno($ch);
			echo '{"curl_error":"' . curl_error($ch) .  '"}';
			self::logVariable($this->result);
			curl_close($ch);
			die();
		}
		curl_close($ch);
		$this->curlerror = false;
		return $this->result;

	}

	public function performQuery ($level, $query, $expand, $limit = 100) {  // limit is 100 if not specified.

		$query = json_decode($query);
		$fullquery = new \stdClass();
		$fullquery->Level = $level;
		$fullquery->Expand = $expand;
		$fullquery->Limit = $limit;
		$fullquery->Query = $query;
		$postfields = json_encode($fullquery);
		$this->executeCURLPOSTJSON($postfields, 'tools/find');
		self::logVariable("tools/find:  " .$postfields);
		return $this->result;

	}

	public function logViewStudy($study) {  // $study is the $_POST or $_Request

		$study_exists = $this->performQuery ("Studies", '{"StudyInstanceUID":"' . $study['StudyInstanceUID'] . '"}', true, $limit = 1);
		$study_exists = count(json_decode($study_exists)) != 0;

		if ($study_exists) {
		    /*
			$study['user_id'] = $_SESSION['user_id'];
			$study['user_name'] = $_SESSION['user_name'];
			$study['viewed'] = date("Y-m-d H:i:s");
			DatabaseFactory::insertarray('audit_study_view', $study, null);
			$myip = $_SERVER['REMOTE_ADDR']; // https://stackoverflow.com/questions/3003145/how-to-get-the-client-ip-address-in-php
			$data = array("user_id" => $study['user_id'], "mrn" => $study['mrn'],  "orthanc_uuid" => $study['uuid'], "StudyInstanceUID" => $study['StudyInstanceUID'], "IPaddress" => $myip);
			*/
			$data = "test";
			setcookie("PACStoken", json_encode($data), [
			'expires' => time() + config('myconfigs.SESSION_RUNTIME'),
			'path' => config('myconfigs.COOKIE_PATH'),
			'domain' => config('myconfigs.COOKIE_DOMAIN'),
			'secure' => config('myconfigs.COOKIE_SECURE'),
			'httponly' => config('myconfigs.COOKIE_HTTP'),
			'samesite' => config('myconfigs.COOKIE_SAMESITE'),
			]);


		$payload = [

		'iss' => 'Orthanc PACS',
		'sub' => 'Viewer Token',
		'iat' => time(),
		'uid' => 1,
		'exp' => time() + 60 * 5,
		'data' => $data

		];
		$secret = 'Hello&MikeFooBar123';
		$token = Token::customPayload($payload, $secret);
		setcookie("JWTVIEWER", $token, [

			'expires' => time() + config('myconfigs.SESSION_RUNTIME'),
			'path' => config('myconfigs.COOKIE_PATH'),
			'domain' => config('myconfigs.COOKIE_DOMAIN'),
			'secure' => config('myconfigs.COOKIE_SECURE'),
			'httponly' => config('myconfigs.COOKIE_HTTP'),
			'samesite' => config('myconfigs.COOKIE_SAMESITE'),
		]);

        if ($this->server->stone_viewer == 1) {
			$link = $this->server->osimis_viewer_link .'study=' . $study['StudyInstanceUID'];
		}
		else {
		$link =  $this->server->osimis_viewer_link .'study=' . $study['uuid'];
		}
		echo '[{"viewstudy":"success","JWT":"' . $token . '","link":"' . $link .'"}]';

		}
		else if (!$study_exists && $this->curlerror = false) {
			echo '[{"error":"Study Not on PACS."}]';
		}
		else if ($this->curlerror = true)  {
			echo '[{"error":"Error Connecting with PACS."}]';
		}

	}

		public function getStudiesArray ($query, $patient = false, $doctor = false, $reader = false) {

		self::logVariable($query);
		$jsonquery = json_encode($query);
		$this->executeCURLPOSTJSON($jsonquery,'studies/page');

		if (!$this->curlerror) {

		$studiesarray = json_decode($this->result);
		$widgetdata = $studiesarray[0];
		array_shift($studiesarray);
		if (count($studiesarray) > 0) {

			self::decodeOrthancStudies($studiesarray);
			DatabaseFactory::logVariable("getStudiesArray, after decoding");
			DatabaseFactory::logVariable($studiesarray);
			// if (property_exists($query->Local, "reportstatus")) DatabaseFactory::logVariable($query->Local->reportstatus);
			if (isset($query->Local)  && property_exists($query->Local, "reportstatus")) {

			foreach ($studiesarray as $key => $study) {
				if ($study->reportstatus != $query->Local->reportstatus) unset($studiesarray[$key]);
			}
			}

		}
		array_unshift($studiesarray,$widgetdata);
		}
		else {
			return "CURLerror";
		}
		$this->result = $studiesarray;
		//echo $limit;
		return $studiesarray;
		}

			private static function addReferrerNames(&$study) {

		$names = explode("^",$study->referring_physician);
		(isset($names[0]))?$study->referring_physician_id = $names[0]:$study->referring_physician_id = "";
		(isset($names[1]))?$study->referrer_last_name = $names[1]:$study->referrer_last_name = "";
		(isset($names[2]))?$study->referrer_first_name = $names[2]:$study->referrer_first_name = "";
		(isset($names[3]))?$study->referrer_middle_name = $names[3]:$study->referrer_middle_name = "";
		(isset($names[4]))?$study->referrer_suffix_name = $names[4]:$study->referrer_suffix_name = "";

	}

		public static function decodeOrthancStudies(&$studyarray) {

	// TO GET raw JSON for testing SPWA
// 	error_log(json_encode($studyarray));
// 	die();
		// converts to local variable names and keeps some from the Orthanc Object.  More readable and names correspond to database.  Basically a map.  Example Orthanc Object at type.
		// imagecount and modalities are passed back from the remote server, but may be undefined.

		foreach ($studyarray as $study) {

			$study->LastUpdate_formatted = isset($study->LastUpdate)?date_create_from_format("Ymd\THis", $study->LastUpdate)->format("Y-m-d H:i:s"):""; // part of Orthanc, "\" required for literal character
			// imagecount and modality are passed back from the server
			$study->uuid = $study->ID;
			$study->patientid = isset($study->PatientMainDicomTags->PatientID)?$study->PatientMainDicomTags->PatientID:"Not Set";
			$study->alt_patientid = isset($study->PatientMainDicomTags->OtherPatientIDs)?$study->PatientMainDicomTags->OtherPatientIDs:"Not Set";
			$study->patient_birth_date = isset($study->PatientMainDicomTags->PatientBirthDate)?$study->PatientMainDicomTags->PatientBirthDate:"Not Set";
			$study->patient_name = isset($study->PatientMainDicomTags->PatientName)?$study->PatientMainDicomTags->PatientName:"Not Set";
			$study->patient_sex = isset($study->PatientMainDicomTags->PatientSex)?$study->PatientMainDicomTags->PatientSex:"-";;

			$study->accession_number = isset($study->MainDicomTags->AccessionNumber)?$study->MainDicomTags->AccessionNumber:"Not Set";
			$study->referring_physician = isset($study->MainDicomTags->ReferringPhysicianName)?$study->MainDicomTags->ReferringPhysicianName:"Not Set";
			$study->institution = isset($study->MainDicomTags->InstitutionName)?$study->MainDicomTags->InstitutionName:"Not Set";
			$study->study_date = isset($study->MainDicomTags->StudyDate)?$study->MainDicomTags->StudyDate:"Not Set";
			$study->study_time = isset($study->MainDicomTags->StudyTime)?$study->MainDicomTags->StudyTime:"Not Set";
			$study->study_description = isset($study->MainDicomTags->StudyDescription)?$study->MainDicomTags->StudyDescription:"Not Set";
			$study->StudyInstanceUID = $study->MainDicomTags->StudyInstanceUID;  // incorporate into description or get from order.  Should always be set
			// missing so far
			$study->created = date_create_from_format("Ymd His", $study->study_date . ' '  . mb_substr($study->study_time, 0, 6));
			if ($study->created) $study->created = $study->created->format("Y-m-d H:i:s");
            $order = false;
			//$order = OrderModel::getShortOrderByAccession($study->accession_number);  // should always exist if there is an order, but maybe not
			$study->indication = (!empty($order))?$order->indication:"No Order"; // migrate to order
			$study->coded_exam = (!empty($order))?$order->coded_exam:"[]"; // migrate to order
			$study->requested_procedure_id =  (!empty($order))?$order->requested_procedure_id:"No Order";  // migrate to order, part of the order
			$study->order_description =  (!empty($order))?$order->description:"No Order";  // migrate to order, part of the order
			//$lastreport = ReportsModel::getLastReportStatusByAccession($study->accession_number); // may or may not exist
			$lastreport = false;
			if ($lastreport != false && $lastreport != "error" ) {
				$study->reportstatus = $lastreport->newstatus;
			}
			else if ($lastreport == false) {
				$study->reportstatus = "NONE";
			}
			else if ($lastreport == "error") {
				$study->reportstatus = "???";
			}
			self::addReferrerNames($study);
			if (!self::$fulltags) {
			unset($study->Series);
			unset($study->MainDicomTags);
			unset($study->PatientMainDicomTags);
			}


		}
	}

}
?>
