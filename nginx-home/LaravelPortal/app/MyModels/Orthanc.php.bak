<?php
namespace App\MyModels;
use \DB;
use \Debugbar;
use App\Actions\Orthanc\UtilityFunctions;
use Illuminate\Support\Facades\Auth;
use ReallySimpleJWT\Token;

Class Orthanc  {

    private $OrthancURL;
    public $result;
    public $server;
//  public $showAll;
    public $curlerror;
    public $curl_error_text;
    private static $Authorization;
    private static $Token;
    private static $Origin;
    private static $userprofileJWT;
    public $responsecode;
    private static $fulltags = true;

    public function __construct() {

    	$this->curlerror = false;

    	if (!isset($_SESSION["orthanc_host"])) {

    		if (config('myconfigs.DEFAULT_ORTHANC_HOST') == "") die("No Default Orthanc Configured.");
    		$_SESSION["orthanc_host"] = config('myconfigs.DEFAULT_ORTHANC_HOST');
    	}

		self::$Authorization = config('myconfigs.API_Authorization');
		self::$Token =  config('myconfigs.API_Token');
		self::$Origin = self::my_server_url();
		self::$userprofileJWT = Auth::user();

// 		self::$userprofileJWT = array (
//
// 		'user_id' => Session::get('user_id'),
//         'user_name' => Session::get('user_name'),
//         'user_email' => Session::get('user_email'),
//         'user_roles' => Session::get('user_roles'),  // array of account types / roles
//         'patientid' => Session::get('patientid'),
//         'doctor_id' => Session::get('doctor_id'),
//         'reader_id' => Session::get('reader_id'),
//         'ip' => $_SERVER['REMOTE_ADDR']
//
// 		);
    	$this->initServer($_SESSION["orthanc_host"]);
//     	$this->showAll = false;
    }
	// Setup the Server local and remote REST API URLS, sets the flag for what kind of server it is also, local or remote.

	public function initServer($serverid) {

		if (!empty($serverid)) {

	    $query = 'SELECT * from orthanc_hosts WHERE id = ?';
    	$this->server = DatabaseFactory::selectByQuery($query, [$serverid])->fetch(\PDO::FETCH_OBJ);
    	$this->OrthancURL = $this->server->api_url;

		}
		else {
			$this->serverid = false;
		}
		DatabaseFactory::logVariable("initServer");
	}

    public function getAPIURL() {

        return $this->OrthancURL;

    }

    private static function my_server_url() {

        $server_name = $_SERVER['SERVER_NAME'];

        if (!in_array($_SERVER['SERVER_PORT'], [80, 443])) {
            $port = ":$_SERVER[SERVER_PORT]";
        } else {
            $port = '';
        }

        if (!empty($_SERVER['HTTPS']) && (strtolower($_SERVER['HTTPS']) == 'on' || $_SERVER['HTTPS'] == '1')) {
            $scheme = 'https';
        } else {
            $scheme = 'http';
        }
        return $scheme.'://'.$server_name.$port;
    }

    public static function logVariable($var) {

		if (gettype($var) == "array" || gettype($var) == "object") {

			ob_start();
			echo json_encode($var, JSON_PRETTY_PRINT);
			$output = ob_get_clean();

		}
		else {
		$output = $var;
		}
		if (DEBUG) error_log($output);
		return $output;

	}

	// Utility Function

    private static function validateDate($date, $format = 'Y-m-d') {
		$d = DateTime::createFromFormat($format, $date);
		// The Y ( 4 digits year ) returns TRUE for any integer with any number of digits so changing the comparison from == to === fixes the issue.
		return $d && $d->format($format) === $date;
	}

	//  GENERIC THINGS TO VALIDATE AN ORTHANC UUID and DICOM tag codes

	private static function checkUUID($uuid) {

		preg_match('/[0-9a-fa-f]{8}\-[0-9a-fa-f]{8}\-[0-9a-fa-f]{8}\-[0-9a-fa-f]{8}\-[0-9a-fa-f]{8}/', $uuid, $matches);
		return (count($matches) == 1);
	}

	private static function checkTagCode($tagcode) {

		preg_match('/[0-9]{4}\-[0-9]{4}/', $tagcode, $matches);
		return (count($matches) == 1);
	}
/**
THESE ARE ALL FOR MAKING API CALL VIA THE NGINX PROXY WITH AUTHENTICATION, MUCH EAISER THAN THE OTHER WAY
NEED TO PASS AUTH in the Headers as a token and have the Origin of the Server here and on the NGINX server
Used for downloadDCMStudyUUID, downloadZipStudyUUID
**/

	private function processCURLResults(&$ch) {

		$this->result = curl_exec($ch);
		$this->responsecode =  curl_getinfo($ch,CURLINFO_HTTP_CODE);
		if (curl_errno($ch) || curl_getinfo($ch,CURLINFO_HTTP_CODE) != "200") {
			$this->curlerror = true;
			$this->curl_error_text = "Status:  " . curl_getinfo($ch,CURLINFO_HTTP_CODE) . ', Error: ' . curl_error($ch);
			curl_close($ch);
			return $this->result;
		}
		else {

			$this->curlerror = false;
			$this->curl_error_text = "No Errors";
			curl_close($ch);
			return $this->result;
		}

	}


	public function executeCURL($CURLOPT_URL) {

		$ch = curl_init();
		curl_setopt($ch, CURLOPT_URL, $this->OrthancURL . $CURLOPT_URL);
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
		curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
		curl_setopt($ch,CURLOPT_ENCODING , "gzip");
		Debugbar::error("executeCURL:  " . $this->OrthancURL . $CURLOPT_URL);
		$headers = array();
		//$headers[] = 'Content-Type: application/x-www-form-urlencoded';
		$headers[] = 'Authorization:' . self::$Authorization;
		$headers[] = 'Token:' . self::$Token;
		$headers[] = 'Origin:' . self::$Origin;
		//$headers[] = 'Accept-Encoding:gzip';
		curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
		return $this->processCURLResults($ch);

	}

	public function executeCURLPOSTJSON($JSONQuery, $url) {

		$ch = curl_init();
		curl_setopt($ch, CURLOPT_URL, $this->OrthancURL . $url);
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
		curl_setopt($ch, CURLOPT_POST, 1);
		curl_setopt($ch, CURLOPT_POSTFIELDS, $JSONQuery);
		curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
		curl_setopt($ch,CURLOPT_ENCODING , "gzip");
		Debugbar::error("OrthancModel->executeCURLPOSTJSON:  " . $this->OrthancURL . $url);
		Debugbar::error("OrthancModel->executeCURLPOSTJSON_Args:  " . $JSONQuery);
		$headers = array();
		$headers[] = 'Authorization:' . self::$Authorization;
		$headers[] = 'Token:' . self::$Token;
		$headers[] = 'Origin:' . self::$Origin;
		$headers[] = 'userprofileJWT:' . json_encode(self::$userprofileJWT);
		$headers[] = 'Accept-Encoding:gzip';
		// $headers[] = 'Content-Type: application/json';
		curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
		return $this->processCURLResults($ch);
	}

	public function executeCURLPOSTJSON_NGINXADMIN($JSONQuery) {


		$ch = curl_init();
		curl_setopt($ch, CURLOPT_URL, $this->server->nginx_admin_url);
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
		curl_setopt($ch, CURLOPT_POST, 1);
		curl_setopt($ch, CURLOPT_POSTFIELDS, $JSONQuery);
		curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
		curl_setopt($ch,CURLOPT_ENCODING , "gzip");
		Debugbar::error("OrthancModel->executeCURLPOSTNGINXAdmin:  " .  $this->server->nginx_admin_url);
		Debugbar::error("Args:  " . $JSONQuery);
		$headers = array();
		$headers[] = 'Authorization:' . self::$Authorization;
		$headers[] = 'Token:' . self::$Token;
		$headers[] = 'Origin:' . self::$Origin;
		$headers[] = 'Accept-Encoding:gzip';
		self::logVariable("Headers:  " . json_encode($headers));
		curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
		return $this->processCURLResults($ch);

	}

	public  function executeCURL_checkViewerStatus() {


		$ch = curl_init();
		curl_setopt($ch, CURLOPT_URL, $this->server->osimis_viewer_check);
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
		curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
		curl_setopt($ch,CURLOPT_ENCODING , "gzip");
		self::logVariable("executeCURL:  " . $this->server->osimis_viewer_check);
		$headers = array();
		$headers[] = 'Content-Type: application/x-www-form-urlencoded';
		$headers[] = 'Authorization:' . self::$Authorization;
		$headers[] = 'Token:' . self::$Token;
		$headers[] = 'Origin:' . self::$Origin;
		$headers[] = 'Accept-Encoding:gzip';

		curl_setopt($ch, CURLOPT_HTTPHEADER, $headers);
		return $this->processCURLResults($ch);

	}

	public function performQuery ($level, $query, $expand, $limit = 100) {  // limit is 100 if not specified.

		$query = json_decode($query);
		$fullquery = new \stdClass();
		$fullquery->Level = $level;
		$fullquery->Expand = $expand;
		$fullquery->Limit = $limit;
		$fullquery->Query = $query;
		$postfields = json_encode($fullquery);
		$this->executeCURLPOSTJSON($postfields, 'tools/find');
		DatabaseFactory::logVariable("tools/find:  " .$postfields);
		return $this->result;

	}

	public function DICOMdestinations() {

    	$this->executeCURL("modalities?expand=");
    	if ($this->curlerror === true) return '<option value="">Server Down</option>';
    	$destinations = json_decode($this->result);
    	$html = '<option value="" disabled selected="selected">Send</option>';
    	foreach ($destinations as $key => $destination) {
    		$html.= '<option value="' . $key . '">' .$key . '</option>';
    	}
    	return $html;

    }

	public function viewerOnline() {


	}
	// passed
	public function ServerStatus() {

		// returns the time if valid

		return $this->executeCURL('tools/now-local');
	}
    // passed
    public function StartServer() {

		return $this->executeCURLPOSTJSON_NGINXADMIN('{"method":"StartServer","Process":"Orthanc"}');
	}
	// passed
	public function StopServer() {

		return $this->executeCURLPOSTJSON_NGINXADMIN('{"method":"StartServer","Process":"Orthanc"}');
	}
	// passed
	public function PHPINFO() {

		return $this->executeCURLPOSTJSON_NGINXADMIN('{"method":"PHPINFO"}');
	}
	// passed
    public static function getServersArray() {

    	$query = 'SELECT * from orthanc_hosts';
    	return DatabaseFactory::selectByQuery($query, [])->fetchAll(\PDO::FETCH_OBJ);

    }

    // passed
    public static function createAPIandInfoFromServerID($id) {

		$query = 'SELECT * from orthanc_hosts WHERE id = ?';
    	$server = DatabaseFactory::selectByQuery($query, [$id])->fetch(\PDO::FETCH_OBJ);
    	if ($server) {
    	$APIStrings = new \stdClass();
    	$APIStrings->base = $server->nginx_admin_url . ' - ' . $server->api_url;
    	$APIStrings->display = $server->nginx_admin_url . ' - ' . $server->api_url .  '/' . '    AET:  ' . $server->AET. '    Name:  ' . $server->server_name ;
    	return $APIStrings;
    	}
    	else return false;

    }


/**
    [HttpError] => Not Found
    [HttpStatus] => 404
    [Message] => Unknown resource
    [Method] => GET
    [OrthancError] => Unknown resource
    [OrthancStatus] => 17
    [Uri] => /patienfdfts/
**/

	// passed
	public function getPatients($uuid = "") {

		if ($uuid == "" || self::checkUUID($uuid)) {
			$this->result = $this->executeCURL("patients/" . $uuid);
			return $this->result;

		}
		else return false;

	}
	// passed

	public function studyCountByPatientId($patientids) {


 		$result = json_decode($this->executeCURLPOSTJSON(json_encode($patientids), 'patient/studycounts'));
 		DatabaseFactory::logVariable(json_encode($result));
		$counts = [];
		foreach ($result as $key => $count) {
			$counts[$key] = $count;
		}
		return $counts;
	}
	// passed
	public function getStudies($uuid = "") {  // same as constructor for subsequent calls.

		if ($uuid == "" || self::checkUUID($uuid)) {
			$this->result = $this->executeCURL("studies/"  . $uuid);
			return $this->result;
		}
		else return false;
	}


	public function getStudyDetails ($uuid) {
	    $uuid = [$uuid];

	    $data = json_encode($uuid );
	    $data =  $this->executeCURLPOSTJSON($data, 'studies/arrayIDs');
		$result = json_decode($this->result);
		StudiesModel::decodeOrthancStudies($result);
		return $result[0];

	}

	public function addPDF($method, $html, $base64, $author, $title, $studyuuid, $return, $attach, $id) {

	    if ($method == "html") {

	    $html = str_replace("\n", "", $html);
	    $html = str_replace("\t", "", $html);
	    $html = str_replace("'", "&rsquo;", $html); // replace with HTML entity.

	    $html = addslashes($html);
	    $html = str_replace("/", "\\/", $html);
	    }
	    $jsonquery = '{"method":"' .$method.  '","html":"' .$html. '","base64":"' .$base64. '","title":"' .$title. '","studyuuid":"' .$studyuuid. '","return":' .$return. ',"attach":' .$attach. ',"author":"' .$author.  '"}';
	    $this->executeCURLPOSTJSON($jsonquery,'pdfkit/htmltopdf');
	    $query = 'UPDATE reports SET json_request_orthanc_add_pdf = ? WHERE id = ?';
	    DatabaseFactory::selectByQuery($query,[ $jsonquery, $id]);
	    return $this->result;

	}



	// passed
	public function getStudiesArray ($query = false) {

		if ($query == false) {

		$query = file_get_contents('php://input');
		}
		$query = json_decode($query);

		if (count(array_intersect($_SESSION['user_roles'], [2])) > 0 && Session::get('view') == "referrers") {

			$query->Query->ReferringPhysicianName = '*' . $_SESSION['doctor_id'] . '*';
			$orthancQuery[] = '"ReferringPhysicianName":"*'  . $_SESSION['doctor_id'] .  '*"';

		}
		if ($_SESSION["view"] == "patients" && !empty($_SESSION['patientid'])) {
			$query->Query->PatientID = $_SESSION['patientid'];
		}
		else if ($_SESSION["view"] == "patients" && empty($_SESSION['patientid'])) {
			echo "You do not have an MRN assigned";
 			die();
		}
		#DatabaseFactory::logVariable($query);
		$jsonquery = json_encode($query);
		$returnedvalue = $this->executeCURLPOSTJSON($jsonquery,'studies/page');
		#DatabaseFactory::logVariable($this);

		if (!$this->curlerror) {

		$studiesarray = json_decode($this->result);
		$widgetdata = $studiesarray[0];
		array_shift($studiesarray);
		if (count($studiesarray) > 0) {

			StudiesModel::decodeOrthancStudies($studiesarray);
			DatabaseFactory::logVariable("getStudiesArray, after decoding");
			DatabaseFactory::logVariable($studiesarray);
			// if (property_exists($query->Local, "reportstatus")) DatabaseFactory::logVariable($query->Local->reportstatus);
			if (isset($query->Local)  && property_exists($query->Local, "reportstatus")) {

			foreach ($studiesarray as $key => $study) {
				if ($study->reportstatus != $query->Local->reportstatus) unset($studiesarray[$key]);
			}
			}

		}
		array_unshift($studiesarray,$widgetdata);
		}
		else {
			return json_decode('{"error":"' .$this->curl_error_text . '"}');
		}
		$this->result = $studiesarray;
		//echo $limit;
		return $studiesarray;
	}


	// passed
	public function getSeries($uuid = false) {  // same as constructor for subsequent calls.

		if ($uuid == "" || self::checkUUID($uuid)) {
			$this->result = $this->executeCURL("series/" . $uuid);
			return $this->result;
		}
		else return false;
	}
	// passed
	public function getInstances($uuid , $withtags) {

		if (self::checkUUID($uuid)) {

			if ($withtags == "simplified-tags" ||  $withtags == "tags") {
			$withtags = ('/' . $withtags );  // detailed info
			$suffix = $uuid . "/" . $withtags;
			}
			else $suffix = $uuid;
		}
		else {

			if (empty($uuid)) $suffix = "";
			else {
			return false;  // returns false if a bad uuid format.
			}
		}

		$this->result = $this->executeCURL("instances/" . $suffix);
		if(!$this->result) echo '[{"error":"No Results"}]';
        return $this->result;

	}
	// passed
	public function getDICOMTagValueforUUID ($uuid, $tagcodes) {

		if (self::checkUUID($uuid)) {

			$errors = false;
			foreach ($tagcodes as $tagcode)  {
				if (!self::checkTagCode($tagcode)) $errors = true;
			}
			if (!$errors) {
			$tagcodes = implode("/", $tagcodes);
			$this->executeCURL("instances/" . $uuid . '/content/' . $tagcodes);
			return $this->result;
			}
		}
		return false;  // gets here if bad uuid or errors in the tagcodes that were passes.

	}
	// passed
	public function getDICOMTagListforUUID($uuid) {

		if (self::checkUUID($uuid)) {

			$this->executeCURL("instances/" . $uuid . '/content');
			return $this->result;  // also returns false if bad response
		}
		return false;
	}
	// passed
	public function getInstanceDICOM($uuid) {

		if (self::checkUUID($uuid)) {
			return $this->executeCURL("instances/" . $uuid . '/file');
		}
		return false;

	}

	 public function pydicom($uuid) {

	 	// returns false or empty if no result
		if (self::checkUUID($uuid)) {
			return $this->executeCURL("pydicom/" . $uuid);
		}
		return false;

	 }
	// passed
	public function getInstancePNGPreview ($uuid, $pngjpg) {

		// returns false or empty if no result
		if (self::checkUUID($uuid)) {
			return $this->executeCURL("instances/" . $uuid . '/preview/', $pngjpg);
		}
		return false;

	}
	// passed
	public function downloadZipStudyUUID ($uuid) {

		$this->executeCURL("studies/" . $uuid . '/archive');
		return $this->result;

	}
	// passed
	public function downloadDCMStudyUUID ($uuid) {

		$this->executeCURL("studies/" . $uuid . '/media');
		return $this->result;


	}

    /*
        Description	"REST API"
        FailedInstancesCount	0
        InstancesCount	305
        LocalAet	"ORTHANC"
        ParentResources	[ "6efb3ff2-4cd16ca1-35cdb247-2d1c5f78-d6ba584e" ]
        0	"6efb3ff2-4cd16ca1-35cdb247-2d1c5f78-d6ba584e"
        RemoteAet	"ORTHANC"

        Details	"DicomAssociation - connecting to AET \"FINDSCU\": Failed to establish association (0006:0317 Peer aborted Association (or never connected); 0006:031c TCP Initialization Error: Connection refused)"
        HttpError	"Internal Server Error"
        HttpStatus	500
        Message	"Error in the network protocol"
        Method	"POST"
        OrthancError	"Error in the network protocol"
        OrthancStatus	9
        Uri	"/modalities/findscu/store/"
*/
	public function fetch_study($id, $uuid) {

	    $ajaxresponse = [];
	    $response = json_decode($this->executeCURLPOSTJSON($uuid, '/modalities/' . $id . '/store/'));
        if (!isset($response->RemoteAet) && $response->RemoteAet != $id) {
            $ajaxresponse['status'] = "error";
            if (isset($response->HttpError)) {
                $ajaxresponse['message'] = $response->HttpError;
            }
            else  $ajaxresponse['message'] = 'Error with Request';
        }
        else {
            $ajaxresponse['status'] = "success";
            $ajaxresponse['message'] = $response->InstancesCount .  " image(s) sent to " .  $id;
        }
        echo json_encode($ajaxresponse);
	    return $ajaxresponse;
	}

	public function saveMWLfile($texttemplate, $filename) {

		echo $this->executeCURLPOSTJSON($data, '/mwl/file/make');
		return $this->result;

	}

	public function saveTestMWL($data) {

		echo $this->executeCURLPOSTJSON($data, '/mwl/file/make');
		return $this->result;

	}

	public function deleteMWLfile($AccessionNumber) {

		return $this->executeCURLPOSTJSON(json_encode([$AccessionNumber]), 'mwl/file/delete');

	}

	public function getOrthancModalities() {

		$this->executeCURL("modalities?expand");
		return $this->result;

	}

	public function getOrthancConfigs($item) {
	    // ALL for ALL
		$this->executeCURL("get-configs/" . $item);
		return str_replace("\n", "", $this->result);

	}

	public function getStoneConfigs() {

		$this->executeCURL("get-configs/StoneWebViewer");
		return $this->result;

	}

}

?>
